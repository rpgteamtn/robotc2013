#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     					HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     					light,          sensorLightActive)
#pragma config(Sensor, S4,     					lift_down,     	sensorTouch)
#pragma config(Motor,  motorA,          lift_en,       	tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          light_m,       	tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             	tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     lift1,         	tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     lift2,         	tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rear_right,    	tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     rear_left,     	tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     front_right,   	tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     front_left,    	tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    scissorb,       tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scissort,       tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    bucket,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,         tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,         tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,         tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-sensormux.h"			// Include file for sensor multiplexer
#include "drivers/hitechnic-irseeker-v2.h"

#define light_value 44
#define TURN_RIGHT true
#define TURN_LEFT  false

#define	DIRECTION_DSP			0
#define COMPASS_REL_DSP		1
#define	COMPASS_HDG_DSP		2
#define FRNT_DRIVE_DSP		3
#define	REAR_DRIVE_DSP		4

#define	IR_SENSOR_DSP			8

#define	STRAFF_FL		50
#define STRAFF_FR		50
#define STRAFF_RL		50
#define STRAFF_RR		50

#define	IR_LEFT			1
#define IR_RIGHT		2
#define	IR_STRAIGHT	3

// Give the sensor a nice easy to use name
const tMUXSensor IR_SENSOR1 = msensor_S2_1;
const tMUXSensor IR_SENSOR2 = msensor_S2_2;
const tMUXSensor SENSOR_ARRAY_3 = msensor_S2_3;
const tMUXSensor SENSOR_ARRAY_4 = msensor_S2_4;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void displayInfo()
{
	//nxtDisplayTextLine(DIRECTION_DSP, strFunction);

//	nxtDisplayTextLine(FRNT_DRIVE_DSP,"%d  %d", nMotorRunState[front_left], nMotorRunState[front_right]);
  //nxtDisplayTextLine(REAR_DRIVE_DSP,"%d  %d", nMotorRunState[rear_left],  nMotorRunState[rear_right]);

//  nxtDisplayTextLine(COMPASS_REL_DSP,"rh: %d", HTMCreadRelativeHeading(HTCOMPASS));
 // nxtDisplayTextLine(COMPASS_HDG_DSP,"ch: %d", HTMCreadHeading(HTCOMPASS));

	//nxtDisplayTextLine(IR_SENSOR_DSP, "IR %d", SensorValue[IRSeeker2]);
	//nxtDisplayTextLine(lift_en, "%d", nMotorEncoder[lift_en]);
	nxtDisplayTextLine(1,"lift %d", nMotorEncoder[lift_en]);
}

//****************************************************************
//  stops all motors
//****************************************************************
void ceaseMotion()
{
 motor[front_left]  = 0;
 motor[rear_left]   = 0;
 motor[front_right] = 0;
 motor[rear_right]  = 0;
}

//****************************************************************
//  Initialize the robot and set defaults
//****************************************************************
void initializeRobot()
{
//	strFunction = "Init Robot";
	servo[scissorb] = 180;
	servo[scissort] = 180;

	disableDiagnosticsDisplay();
	displayInfo();
	wait1Msec( 250 );
  return;
}

//****************************************************************
//  move directly to the left
//****************************************************************
void straffLeft()
{
	int power = 70;
	motor(front_left)  = -power;
	motor(front_right) = power;
	motor(rear_left)   = power;
	motor(rear_right)  = -power;
	}

//****************************************************************
//  move directly to the right
//****************************************************************
void straffRight()
{
	int power = 70;
	motor(front_left)  = power;
	motor(front_right) = -power;
	motor(rear_left)   = -power;
	motor(rear_right)  = power;
}

//****************************************************************
// straff to right until white line or 5 seconds pass
//****************************************************************
void straffrlight( )
{
	int moveRight = true;

  nMotorEncoder(light_m) = 0;
  nMotorEncoderTarget(light_m) = 163;
  motor(light_m) = 30;
  while(nMotorRunState[light] != runStateIdle)
   {
   }
  wait1Msec(500);
  ClearTimer(T1);
	while( SensorValue[light] < light_value && time1(T1) < 2500 )
	{
		if(moveRight == true)
		{
			int power = 30;
			motor(front_left)  = power;
			motor(front_right) = -power;
			motor(rear_left)   = -power;
			motor(rear_right)  = power;
		}
	}
	ceaseMotion();
	wait1Msec(100);
	nMotorEncoder(light_m) = 0;
  while ( abs(nMotorEncoder(light_m)) < 165)
  {
		motor(light_m) = -30;
  }

  wait1Msec(100);
}
//****************************************************************
// straff for encoder clicks right or left
//****************************************************************

void straff( int clicks, bool moveRight )
{
	nMotorEncoder(rear_left)=0;
	while( abs(nMotorEncoder(rear_left)) < clicks )
	{
		if(moveRight == true)
		{
			straffRight();
		}
		else
		{
			straffLeft();
		}
	}
	ceaseMotion();
	wait1Msec(300);
}

//****************************************************************
//  move a number of clicks, set the power, and wait a number of milliseconds
//****************************************************************
void forward (int coder_clicks, int power, int msec_wait)
{
//	strFunction = "forward";

	bFloatDuringInactiveMotorPWM = false;
  nMotorEncoder[rear_left]   = 0;
  nMotorEncoder[rear_right]  = 0;
  nMotorEncoder[front_left]  = 0;
  nMotorEncoder[front_right] = 0;

  nMotorEncoderTarget[rear_left]   = coder_clicks;
  nMotorEncoderTarget[rear_right]  = coder_clicks;
  nMotorEncoderTarget[front_left]  = coder_clicks;
  nMotorEncoderTarget[front_right] = coder_clicks;

  motor[front_left]  = power;
  motor[rear_left]   = power;
  motor[front_right] = power;
  motor[rear_right]  = power;
  while(nMotorRunState[rear_left] != runStateIdle)
  	// || nMotorRunState[rear_right] != runStateIdle || nMotorRunState[front_left] != runStateIdle || nMotorRunState[front_right] != runStateIdle)
  {
  	displayInfo();
  }

	if(msec_wait > 0) {
	  ceaseMotion();
		displayInfo();
	  wait1Msec(msec_wait);
	}
}

//****************************************************************
// same as previous, but backwards
//****************************************************************
void reverse (int coder_clicks, int power, int msec_wait)
{
//	strFunction = "reverse";
	bFloatDuringInactiveMotorPWM = false;
  nMotorEncoder[rear_left]   = 0;
  nMotorEncoder[rear_right]  = 0;
  nMotorEncoder[front_left]  = 0;
  nMotorEncoder[front_right] = 0;

  nMotorEncoderTarget[rear_left] = coder_clicks;
  nMotorEncoderTarget[rear_right] = coder_clicks;
  nMotorEncoderTarget[front_left] = coder_clicks;
  nMotorEncoderTarget[front_right] = coder_clicks;

  motor[front_left] = -power;
  motor[rear_left] = -power;
  motor[front_right] = -power;
  motor[rear_right] = -power;
  while(nMotorRunState[rear_left] != runStateIdle || nMotorRunState[rear_right] != runStateIdle || nMotorRunState[front_left] != runStateIdle || nMotorRunState[front_right] != runStateIdle)
  {
  	displayInfo();
  }

  ceaseMotion();
  displayInfo();
  wait1Msec(msec_wait);
}

void runLift( int clicks, int waitTime, int power )
{
	nMotorEncoder[lift_en] = 0;
	nMotorEncoderTarget[lift_en] = abs(clicks);
	while( abs(nMotorEncoder[lift_en]) < clicks )
	{
		motor[lift1] = power;
		motor[lift2] = -power;
		nxtDisplayTextLine(1,"en %d", nMotorEncoder[lift_en]);
	}

	motor[lift1] = 0;
	motor[lift2] = 0;
	wait1Msec(waitTime);
}

//****************************************************************
// turn left based on encoder count
//****************************************************************
void hardturn (int clicks, int msec_wait)
{
	nMotorEncoder(rear_left) = 0;
  while( abs(nMotorEncoder(rear_left)) < clicks )
		{
			motor[front_left] = -40;
			motor[rear_left] = -40;
			motor[front_right] = 40;
			motor[rear_right] = 40;
		}
		motor[front_left] = 0;
			motor[rear_left] = 0;
			motor[front_right] = 0;
			motor[rear_right] = 0;
			wait1Msec( msec_wait );
}
//****************************************************************
// move forward based on time
//****************************************************************
void forward_time(int sec)
{
	motor[front_left] = 40;
	motor[rear_left] = 40;
	motor[front_right] = 40;
	motor[rear_right] = 40;
	wait1Msec( sec );
	motor[front_left] = 0;
	motor[rear_left] = 0;
	motor[front_right] = 0;
	motor[rear_right] = 0;
	wait1Msec( 250 );
}

int readIR()
{
  int _dirAC1 = 0;
  int _dirAC2 = 0;

	_dirAC1 = HTIRS2readACDir(IR_SENSOR1);
	_dirAC2 = HTIRS2readACDir(IR_SENSOR2);

	if( (_dirAC1 == 3) && (_dirAC2 == 9) ) {
		return IR_RIGHT;
	}
	if( (_dirAC1 == 1) && (_dirAC2 == 7) ) {
		return IR_LEFT;
	}

	return IR_STRAIGHT;
}

void runLiftTimeClicks( int clicks, int runTime, int waitTime, int power)
{
	ClearTimer(T1);
	nMotorEncoder[lift_en] = 0;
	nMotorEncoderTarget[lift_en] = abs(clicks);
	while( abs(nMotorEncoder[lift_en]) < clicks && time1(T1) < runTime )
	{
		motor[lift1] = power;
		motor[lift2] = -power;
		nxtDisplayTextLine(1,"en %d", nMotorEncoder[lift_en]);
	}

	motor[lift1] = 0;
	motor[lift2] = 0;
	wait1Msec(waitTime);
}


void placeRing()
{
	servo[scissorb] = 90;
	servo[scissort] = 90;
	wait10Msec(100);
	runLift( 400, 100, 100);
	servo[scissorb] = 180;
	servo[scissort] = 180;
	wait10Msec(100);
}

void liftBottom()
{
	nMotorEncoder[lift_en] = 0;
	while( abs(nMotorEncoder[lift_en]) < 2400 && SensorValue(lift_down) == 0 )
	{
		motor[lift1] = 100;
		motor[lift2] = -100;
	}
	motor[lift1] = 0;
	motor[lift2] = 0;
}

task lift_up_down()
{
	while(true)
	{
		runLiftTimeClicks(2700, 4500, 100, -100);
		placeRing();
		liftBottom();
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         Main Task
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
	StartTask(lift_up_down);
  initializeRobot();
	wait10Msec( 20 );
	straffLeft();
	wait10Msec( 200 );
	hardturn( 4000, 30 );
	straffLeft();
	wait10Msec( 200 );
	ceaseMotion();
	StopTask(lift_up_down);
	liftBottom();
}
