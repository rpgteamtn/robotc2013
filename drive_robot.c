#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     IRSeeker2,      sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     HTCOMPASS,      sensorI2CCustom)
#pragma config(Sensor, S4,     lift_down,      sensorTouch)
#pragma config(Motor,  motorA,          lift_en,       tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          light_m,       tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     lift1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rear_left,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     rear_right,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     front_left,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     front_right,   tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    scissorb,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scissort,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    bucket,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define	STRAFF_FL		28
//#define STRAFF_FR		36
//#define STRAFF_RL		56
//#define STRAFF_RR		66

#define	STRAFF_FL			50
#define STRAFF_FR			50
#define STRAFF_RL			50
#define STRAFF_RR			50

#define SLOW_MOVEMENT 30
#define SERVO_MOVEMENT 3

#define LIFT_VALUE_UP 	100
#define LIFT_VALUE_DOWN -50

#define LIFT_ENCODER_START	0
#define LIFT_ENCODER_DISP		630
#define LIFT_ENCODER_RUNG1	415
#define LIFT_ENCODER_RUNG2	1600
#define LIFT_ENCODER_RUNG3	2775

#define SERVO_MAX 180
#define SERVO_MIN 90

#include "JoystickDriver.c" // for the buttons
#include "drivers/hitechnic-compass.h"

int threshold = 10;
bool motorRun;
bool liftRun;
int  targetLocation;
bool bTaskRunning = false;

void turn (int amount_turn, int msec_wait) //+ to right -to left
{
  HTMCsetTarget(HTCOMPASS);
 	if (amount_turn > 0)// turn right
  {
   	while(HTMCreadRelativeHeading(HTCOMPASS) < amount_turn) {
      motor[front_left] = -20;
      motor[rear_left] = -20;
      motor[front_right] = -20;
      motor[rear_right] = -20;
    }
  }
	if (amount_turn < 0) //turn left
  {
  	while(HTMCreadRelativeHeading(HTCOMPASS) > amount_turn) {
      motor[front_left] = 20;
      motor[rear_left] = 20;
      motor[front_right] = 20;
      motor[rear_right] = 20;
 		}
	}

  motor[front_left] = 0;
  motor[rear_left] = 0;
  motor[front_right] = 0;
  motor[rear_right] = 0;
  wait1Msec(msec_wait);
}

void forwardSlow() //move forward at set power (slowly)
{
	motor[front_left] = SLOW_MOVEMENT;
  motor[rear_left] = SLOW_MOVEMENT;
  motor[front_right] = -SLOW_MOVEMENT;
  motor[rear_right] = -SLOW_MOVEMENT;
  motorRun = true;
}
void backwardSlow() //move backward at set power (slowly)
{
	motor[front_left] = -SLOW_MOVEMENT;
  motor[rear_left] = -SLOW_MOVEMENT;
  motor[front_right] = SLOW_MOVEMENT;
  motor[rear_right] = SLOW_MOVEMENT;
  motorRun = true;
}
void rightSlow() //move forward at set power (slowly)
{
	motor[front_left] = -SLOW_MOVEMENT;
  motor[rear_left] = -SLOW_MOVEMENT;
  motor[front_right] = -SLOW_MOVEMENT;
  motor[rear_right] = -SLOW_MOVEMENT;
  motorRun = true;
}
void leftSlow() //move backward at set power (slowly)
{
	motor[front_left] = SLOW_MOVEMENT;
  motor[rear_left] = SLOW_MOVEMENT;
  motor[front_right] = SLOW_MOVEMENT;
  motor[rear_right] = SLOW_MOVEMENT;
  motorRun = true;
}

void lightBack() //pull in an extended light sensor
{
	motor(light_m) = -30;
	motorRun = true;
}

void moveServo( int rate )
{
	servo[scissorb] = (ServoValue[scissorb] + rate);
	servo[scissort] = (ServoValue[scissort] + rate);
}

void runLift( int power )
{
	// make sure we are not lowering lift when it is on the sensor
	if( (power == LIFT_VALUE_DOWN) && SensorValue(lift_down) == 1 ) {
		nMotorEncoder[lift_en] = LIFT_ENCODER_START;
		return;
	}
	motor[lift1] = -power;
	motor[lift2] = power;
	liftRun = true;

	nxtDisplayTextLine(1,"en %d", nMotorEncoder[lift_en]);
}

task extendServo()
{
	servo[scissorb] = SERVO_MIN;
	servo[scissort] = SERVO_MIN;
}
task retractServo()
{
	servo[scissorb] = SERVO_MAX;
	servo[scissort] = SERVO_MAX;
}
task runLift2Value()
{
	bTaskRunning = true;

	int currentValue = nMotorEncoder[lift_en];
	// determine the differnce
	int difference = targetLocation - abs(currentValue);
	if( difference < 0 ) {
		// run lift down until we hit the target or hit the sensor
		while( (abs(nMotorEncoder[lift_en]) > targetLocation) && (SensorValue(lift_down) == 0) ) {
			motor[lift1] = -LIFT_VALUE_DOWN;
			motor[lift2] = LIFT_VALUE_DOWN;
		}
	}
	else {
		// run lift up
		while( abs(nMotorEncoder[lift_en]) < targetLocation ) {
			motor[lift1] = -LIFT_VALUE_UP;
			motor[lift2] = LIFT_VALUE_UP;
		}
	}
	bTaskRunning = false;
}

void setLift( int Location )
{
	targetLocation = abs(Location);
	StartTask(runLift2Value);
}

void cancelLift()
{
	if( bTaskRunning == true ) {
		StopTask(runLift2Value);
		bTaskRunning = false;
	}
}
void ceaseLiftMotion()
{
	motor[lift1] = 0;
	motor[lift2] = 0;
}

void movementStd( int speed1, int speed2, int speed3, int speed4 )
{
	motor(front_left) = speed1;
	motor(front_right) = speed2;
	motor(rear_left) = speed3;
	motor(rear_right) = speed4;
	motorRun = true;
}

void movementStd1( int speed1, int speed2, int speed3, int speed4 )
{
			float Angle = 0 ;                 //use gyro to get current angle ? or compas sensor?
      float RobotSpeed = -(joystick.joy1_x2/125)*2; // constant for change of rotation speed -2,2 is range
      float chgspddir = (joystick.joy1_y1/127)*1;
			float mlf = (RobotSpeed*sin(degreesToRadians(Angle+45))+ (chgspddir/3))*150;
			float mrf = (RobotSpeed*cos(degreesToRadians(Angle+45))- (chgspddir/3))*150;
			float mlr = (RobotSpeed*cos(degreesToRadians(Angle+45))+ (chgspddir/3))*150;
			float mrr = (RobotSpeed*sin(degreesToRadians(Angle+45))- (chgspddir/3))*150;

			motor(front_left) = speed1;
	motor(front_right) = speed2;
	motor(rear_left) = speed3;
	motor(rear_right) = speed4;
	motorRun = true;
}

void straffe( int power )
{
  motor(front_left)  = -power;
  motor(front_right) = power;
  motor(rear_left)   = -power;
  motor(rear_right)  = power;
  motorRun = true;
}

void initializeRobot()
{
	disableDiagnosticsDisplay();
	nMotorEncoder[lift_en] = LIFT_ENCODER_START;

	servo[scissorb] = SERVO_MAX;
	servo[scissort] = SERVO_MAX;

	bFloatDuringInactiveMotorPWM = false;

	return;
}

task main()
{
	initializeRobot();
  waitForStart();   // wait for start of tele-op phase

	while( true ) {

		motorRun = false;
		liftRun = false;
		getJoystickSettings(joystick);

		if( joystick.joy2_TopHat == 6) {
			StartTask(extendServo);
			setLift(LIFT_ENCODER_DISP);
		}

		if( joystick.joy2_TopHat == 2) {
			StartTask(retractServo);
			setLift(LIFT_ENCODER_RUNG1);
		}

		if( joy2Btn(1) == 1 ) {
			StartTask(retractServo);
			setLift(LIFT_ENCODER_RUNG2);
		}

		if( joy2Btn(3) == 1) {
			StartTask(retractServo);
			setLift(LIFT_ENCODER_RUNG3);
		}

		if( joy1Btn(4) == 1) {
				forwardSlow();
		}
		if( joy1Btn(2) == 1) {
				backwardSlow();
		}
		if( joy1Btn(1) == 1) {
				leftSlow();
		}
		if( joy1Btn(3) == 1) {
				rightSlow();
		}

		if( joy1Btn(7) == 1 || joy1Btn(5) == 1 ) {
				lightBack();
		}

		if( (joystick.joy2_TopHat == 4 || joy2Btn(2) == 1) && ServoValue[scissorb] < SERVO_MAX) {
		 		moveServo(SERVO_MOVEMENT);
		}

		if( ( joystick.joy2_TopHat == 0 || joy2Btn(4) == 1)&& ServoValue[scissorb] > SERVO_MIN) {
				moveServo(-SERVO_MOVEMENT);
		}

		if( (joy2Btn (8) == 1 || joy2Btn (7) == 1) ) {
		 		runLift(LIFT_VALUE_DOWN);
		 		cancelLift();
		}
		if( joy2Btn(6) == 1 || joy2Btn(5) == 1 ) {
				runLift(LIFT_VALUE_UP);
				cancelLift();
		}
		if( liftRun == false && bTaskRunning == false) {
				ceaseLiftMotion();
 		}

			float Angle = 0 ;                 //use gyro to get current angle ? or compas sensor?
      float RobotSpeed = -(joystick.joy1_x2/125)*2; // constant for change of rotation speed -2,2 is range
      float chgspddir = (joystick.joy1_y1/127)*1;
			float mlf = (RobotSpeed*sin(degreesToRadians(Angle+45))+ (chgspddir/3))*150;
			float mrf = (RobotSpeed*cos(degreesToRadians(Angle+45))- (chgspddir/3))*150;
			float mlr = (RobotSpeed*cos(degreesToRadians(Angle+45))+ (chgspddir/3))*150;
			float mrr = (RobotSpeed*sin(degreesToRadians(Angle+45))- (chgspddir/3))*150;

      if ( (abs(mlf) > threshold && abs(mrf) > threshold && abs(mlr) > threshold && abs(mrr) > threshold) && abs(nMotorEncoder[lift_en]) < 1500 ) //2100 clicks
      	{
					movementStd(mlf*2, mrf*2, mlr*2, mrr*2);
        }
      else if ( (abs(mlf) > threshold && abs(mrf) > threshold && abs(mlr) > threshold && abs(mrr) > threshold))
      	{
      		movementStd(mlf, mrf, mlr, mrr);
        }

		if(joystick.joy1_TopHat == 4) {     // If the left most  joy1's D-Pad ('TopHat') is pressed:
			straffe(SLOW_MOVEMENT);
		}
		if(joystick.joy1_TopHat == 0) {
			straffe(-SLOW_MOVEMENT);
		}

		if(joystick.joy1_TopHat == 6)     // If the left most  joy1's D-Pad ('TopHat') is pressed:
		{
			if( joy1Btn(6) == 1  || joy1Btn(8) == 1 )
			{
				motor(front_left)  = STRAFF_FL * 2;
				motor(front_right) = STRAFF_FR * 2;
				motor(rear_left)   = -STRAFF_RL * 2;
				motor(rear_right)  = -STRAFF_RR * 2;
				motorRun = true;
			}
			else
			{
				motor(front_left)  = STRAFF_FL;
				motor(front_right) = STRAFF_FR;
				motor(rear_left)   = -STRAFF_RL;
				motor(rear_right)  = -STRAFF_RR;
				motorRun = true;
			}
		}
   if(joystick.joy1_TopHat == 2)     // If the right most  joy1's D-Pad ('TopHat') is pressed:
   	{
   		if( joy1Btn(5) == 1 || joy1Btn(6) == 1 || joy1Btn(7) == 1 || joy1Btn(8) == 1 )
  		{
  	 	motor(front_left)  = -STRAFF_FL * 2;
   	 	motor(front_right) = -STRAFF_FR * 2;
   	 	motor(rear_left)   = STRAFF_RL * 2;
   	 	motor(rear_right)  = STRAFF_RR * 2;
   	 	motorRun = true;
  		}
		else
			{
   	  motor(front_left)  = -STRAFF_FL;
   	  motor(front_right) = -STRAFF_FR;
  	   motor(rear_left)   = STRAFF_RL;
   	  motor(rear_right)  = STRAFF_RR;
   	  motorRun = true;
 		  }
  	}
   if(motorRun == false)
   	{
     motor(front_left) = 0;
     motor(front_right) = 0;
     motor(rear_left) = 0;
     motor(rear_right) = 0;
    }

  }
}
