#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     					HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     					light,          sensorLightActive)
#pragma config(Sensor, S4,     					lift_down,     	sensorTouch)
#pragma config(Motor,  motorA,          lift_en,       	tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          light_m,       	tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             	tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     lift1,         	tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     lift2,         	tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rear_right,    	tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     rear_left,     	tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     front_right,   	tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     front_left,    	tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    scissorb,       tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    scissort,       tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    bucket,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,         tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,         tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,         tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-sensormux.h"			// Include file for sensor multiplexer
#include "drivers/hitechnic-irseeker-v2.h"

#define light_value 44
#define TURN_RIGHT true
#define TURN_LEFT  false

#define	DIRECTION_DSP			0
#define COMPASS_REL_DSP		1
#define	COMPASS_HDG_DSP		2
#define FRNT_DRIVE_DSP		3
#define	REAR_DRIVE_DSP		4

#define	IR_SENSOR_DSP			8

#define	STRAFF_FL		50
#define STRAFF_FR		50
#define STRAFF_RL		50
#define STRAFF_RR		50

#define	IR_LEFT			1
#define IR_RIGHT		2
#define	IR_STRAIGHT	3

// Give the sensor a nice easy to use name
const tMUXSensor IR_SENSOR1 = msensor_S2_1;
const tMUXSensor IR_SENSOR2 = msensor_S2_2;
//const tMUXSensor SENSOR_ARRAY_3 = msensor_S2_3;
//const tMUXSensor SENSOR_ARRAY_4 = msensor_S2_4;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void displayInfo()
{
	//nxtDisplayTextLine(DIRECTION_DSP, strFunction);

//	nxtDisplayTextLine(FRNT_DRIVE_DSP,"%d  %d", nMotorRunState[front_left], nMotorRunState[front_right]);
  //nxtDisplayTextLine(REAR_DRIVE_DSP,"%d  %d", nMotorRunState[rear_left],  nMotorRunState[rear_right]);

//  nxtDisplayTextLine(COMPASS_REL_DSP,"rh: %d", HTMCreadRelativeHeading(HTCOMPASS));
 // nxtDisplayTextLine(COMPASS_HDG_DSP,"ch: %d", HTMCreadHeading(HTCOMPASS));

	nxtDisplayTextLine(3,"IR %d", HTIRS2readACDir(IR_SENSOR1));
	nxtDisplayTextLine(4,"IR %d", HTIRS2readACDir(IR_SENSOR2));
	nxtDisplayTextLine(1,"lift %d", nMotorEncoder[lift_en]);
}

//****************************************************************
//  stops all motors
//****************************************************************
void ceaseMotion()
{
 motor[front_left]  = 0;
 motor[rear_left]   = 0;
 motor[front_right] = 0;
 motor[rear_right]  = 0;
}

//****************************************************************
//  Initialize the robot and set defaults
//****************************************************************
void initializeRobot()
{
//	strFunction = "Init Robot";
	servo[scissorb] = 180;
	servo[scissort] = 180;

	disableDiagnosticsDisplay();
	displayInfo();
	wait1Msec( 250 );
  return;
}

//****************************************************************
//  move directly to the left
//****************************************************************
void straffLeft()
{
	int power = 70;
	motor(front_left)  = -power;
	motor(front_right) = power;
	motor(rear_left)   = power;
	motor(rear_right)  = -power;
	}

//****************************************************************
//  move directly to the right
//****************************************************************
void straffRight()
{
	int power = 70;
	motor(front_left)  = power;
	motor(front_right) = -power;
	motor(rear_left)   = -power;
	motor(rear_right)  = power;
}
// recall light
task lightDown()
{
	nMotorEncoder(light_m) = 0;
  while ( abs(nMotorEncoder(light_m)) < 165)
  {
		motor(light_m) = -30;
  }
}

//****************************************************************
// straff to right until white line or 5 seconds pass
//****************************************************************
void straffrlight( )
{
	int moveRight = true;

  ClearTimer(T1);
	while( SensorValue[light] < light_value && time1(T1) < 2500 )
	{
		if(moveRight == true)
		{
			int power = 25;
			motor(front_left)  = power;
			motor(front_right) = -power;
			motor(rear_left)   = -power;
			motor(rear_right)  = power;
		}
	}
	ceaseMotion();
	wait1Msec(100);
	StartTask(lightDown);
  wait1Msec(100);
}
//****************************************************************
// straff for encoder clicks right or left
//****************************************************************

void straff( int clicks, bool moveRight )
{
	nMotorEncoder(rear_left)=0;
	while( abs(nMotorEncoder(rear_left)) < clicks )
	{
		if(moveRight == true)
		{
			straffRight();
		}
		else
		{
			straffLeft();
		}
	}
	ceaseMotion();
	wait1Msec(300);
}

//****************************************************************
//  move a number of clicks, set the power, and wait a number of milliseconds
//****************************************************************
void forward (int coder_clicks, int power, int msec_wait)
{
//	strFunction = "forward";

	bFloatDuringInactiveMotorPWM = false;
  nMotorEncoder[rear_left]   = 0;
  nMotorEncoder[rear_right]  = 0;
  nMotorEncoder[front_left]  = 0;
  nMotorEncoder[front_right] = 0;

  nMotorEncoderTarget[rear_left]   = coder_clicks;
  nMotorEncoderTarget[rear_right]  = coder_clicks;
  nMotorEncoderTarget[front_left]  = coder_clicks;
  nMotorEncoderTarget[front_right] = coder_clicks;

  motor[front_left]  = power;
  motor[rear_left]   = power;
  motor[front_right] = power;
  motor[rear_right]  = power;
  while(nMotorRunState[rear_left] != runStateIdle)
  {
  	displayInfo();
  }

	if(msec_wait > 0) {
	  ceaseMotion();
		displayInfo();
	  wait1Msec(msec_wait);
	}
}

//****************************************************************
// same as previous, but backwards
//****************************************************************
void reverse (int coder_clicks, int power, int msec_wait)
{
//	strFunction = "reverse";
	bFloatDuringInactiveMotorPWM = false;
  nMotorEncoder[rear_left]   = 0;
  nMotorEncoder[rear_right]  = 0;
  nMotorEncoder[front_left]  = 0;
  nMotorEncoder[front_right] = 0;

  nMotorEncoderTarget[rear_left] = coder_clicks;
  nMotorEncoderTarget[rear_right] = coder_clicks;
  nMotorEncoderTarget[front_left] = coder_clicks;
  nMotorEncoderTarget[front_right] = coder_clicks;

  motor[front_left] = -power;
  motor[rear_left] = -power;
  motor[front_right] = -power;
  motor[rear_right] = -power;
  while(nMotorRunState[rear_left] != runStateIdle || nMotorRunState[rear_right] != runStateIdle || nMotorRunState[front_left] != runStateIdle || nMotorRunState[front_right] != runStateIdle)
  {
  	displayInfo();
  }

  ceaseMotion();
  displayInfo();
  wait1Msec(msec_wait);
}

void runLift( int clicks, int waitTime, int power )
{
	nMotorEncoder[lift_en] = 0;
	nMotorEncoderTarget[lift_en] = abs(clicks);
	while( abs(nMotorEncoder[lift_en]) < clicks )
	{
		motor[lift1] = power;
		motor[lift2] = -power;
		nxtDisplayTextLine(1,"en %d", nMotorEncoder[lift_en]);
	}

	motor[lift1] = 0;
	motor[lift2] = 0;
	wait1Msec(waitTime);
}

//****************************************************************
// turn left based on encoder count
//****************************************************************
void hardturn (int clicks, int msec_wait)
{
	nMotorEncoder(rear_left) = 0;
  while( abs(nMotorEncoder(rear_left)) < clicks )
	{
		motor[front_left] = -40;
		motor[rear_left] = -40;
		motor[front_right] = 40;
		motor[rear_right] = 40;
	}
	motor[front_left] = 0;
	motor[rear_left] = 0;
	motor[front_right] = 0;
	motor[rear_right] = 0;
	wait1Msec( msec_wait );
}
//****************************************************************
// turn left based on encoder count
//****************************************************************
void rightturn (int clicks, int msec_wait)
{
	nMotorEncoder(rear_right) = 0;
  while( abs(nMotorEncoder(rear_right)) < clicks )
	{
		motor[front_left] = 40;
		motor[rear_left] = 40;
		motor[front_right] = -40;
		motor[rear_right] = -40;
	}
	motor[front_left] = 0;
	motor[rear_left] = 0;
	motor[front_right] = 0;
	motor[rear_right] = 0;
	wait1Msec( msec_wait );
}
//****************************************************************
// move forward based on time
//****************************************************************
void forward_time(int sec)
{
	motor[front_left] = 40;
	motor[rear_left] = 40;
	motor[front_right] = 40;
	motor[rear_right] = 40;
	wait1Msec( sec );
	motor[front_left] = 0;
	motor[rear_left] = 0;
	motor[front_right] = 0;
	motor[rear_right] = 0;
	wait1Msec( 250 );
}

int readIR()
{
  int _dirAC1 = 0;
  int _dirAC2 = 0;
  nxtDisplayTextLine(3,"IR %d", HTIRS2readACDir(IR_SENSOR1));
	nxtDisplayTextLine(4,"IR %d", HTIRS2readACDir(IR_SENSOR2));

	_dirAC1 = HTIRS2readACDir(IR_SENSOR1);
	_dirAC2 = HTIRS2readACDir(IR_SENSOR2);

	if( (_dirAC1 == 3) && (_dirAC2 == 9) ) {
		return IR_RIGHT;
	}
	if( (_dirAC1 == 1) && (_dirAC2 == 7) ) {
		return IR_LEFT;
	}

	return IR_STRAIGHT;
}

void runLiftTimeClicks( int clicks, int runTime, int waitTime, int power)
{
	ClearTimer(T1);
	nMotorEncoder[lift_en] = 0;
	nMotorEncoderTarget[lift_en] = abs(clicks);
	while( abs(nMotorEncoder[lift_en]) < clicks && time1(T1) < runTime )
	{
		motor[lift1] = power;
		motor[lift2] = -power;
		nxtDisplayTextLine(1,"en %d", nMotorEncoder[lift_en]);
	}

	motor[lift1] = 0;
	motor[lift2] = 0;
	wait1Msec(waitTime);
}



void liftBottom()
{
	nMotorEncoder[lift_en] = 0;
	while( nMotorEncoder[lift_en] < 2400 && SensorValue(lift_down) == 0 )
	{
		motor[lift1] = 30;
		motor[lift2] = -30;
	}
	motor[lift1] = 0;
	motor[lift2] = 0;
}
void placeRing()
{
	servo[scissorb] = 90;
	servo[scissort] = 90;
	wait10Msec(100);
	liftBottom();
	servo[scissorb] = 180;
	servo[scissort] = 180;
	wait10Msec(100);
}

task _lightd()
{
	nMotorEncoder(light_m) = 0;
  nMotorEncoderTarget(light_m) = 163;
  motor(light_m) = 30;
  while(nMotorRunState[light] != runStateIdle)
  {
  }
}
// Align lift to post
task _runLd()
{
		runLiftTimeClicks( 75, 4500, 100, 100);
}
//move lift to free light
task _runL()
{
	runLift( 650, 100, -100);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         Main Task
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
  initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.
	forward( 4500, 70, 100 );
	forward_time(2000); //hit the wall to adjust straight
	StartTask(_runL);
	StartTask(_lightd);
	reverse( 3700, 50, 100 );
	straffrlight();

	switch (readIR()) {
	case	IR_RIGHT:
				straff(2330, TURN_RIGHT);
				hardturn( 30, 10 );
				StartTask(_runLd);
				forward( 2800, 50, 100);
				break;
	case	IR_LEFT:
				straff(2450, TURN_LEFT);
				rightturn( 7, 10 );
				StartTask(_runLd);
				forward( 3100, 50, 100);
				break;
	case	IR_STRAIGHT:
				StartTask(_runLd);
				forward( 2800, 50, 100);
				break;
	}

	placeRing();
	reverse(1500, 30, 100);
	//liftBottom();
	runLiftTimeClicks( -100, 1000, 100, 100);
}
